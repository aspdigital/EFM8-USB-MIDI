C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/17/2019 17:13:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE EFM8_USB_MIDI_MAIN
OBJECT MODULE PLACED IN .\src\EFM8-USB-MIDI_main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\apeters
                    -.SPECSERV\Projects\EFM8-USB-MIDI\src\EFM8-USB-MIDI_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOAT
                    -FUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\apeters.SPECSERV\Projects\EFM8-U
                    -SB-MIDI\inc;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\inc\config;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI
                    -\usb_audio\inc;${workspace_loc:/;${workspace_loc:/;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_memory_
                    -lcd\inc;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_memory_lcd\inc\config;${workspace_loc:/;${workspac
                    -e_loc:/C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_joystick;${workspace_loc:/C:\Users\apeters.SPECSERV
                    -\Projects\EFM8-USB-MIDI\lib\bsp\efm8_rgb_led;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/share
                    -d/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/inc;C:/SiliconLabs/Simplicity
                    -Studio/v4/developer/sdks/8051/v4.1.6//Lib/efm8_usb/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Li
                    -b/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_joystick;C:/Silico
                    -nLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc;C:/SiliconLabs/SimplicityS
                    -tudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/graphics;C:/SiliconLabs/SimplicityStudio/v4
                    -/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/config;C:/SiliconLabs/SimplicityStudio/v4/developer
                    -/sdks/8051/v4.1.6//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/EFM8UB2_SLSTK2001
                    -A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_rgb_led;C:/SiliconLabs/
                    -SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/peripheral_driver/inc) PRINT(.\src\EFM8-USB-MIDI_main.lst
                    -) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src\EFM8-USB-MIDI_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/EFM8-USB-MIDI_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include <SI_EFM8UB2_Register_Enums.h>                  // SFR declarations
  13          #include "InitDevice.h"
  14          // $[Generated Includes]
  15          #include "efm8_usb.h"
  16          // [Generated Includes]$
  17          #include "rgb_led.h"
  18          #include "bsp.h"
  19          #include "disp.h"
  20          #include "render.h"
  21          #include "tick.h"
  22          #include "joybutton.h"
  23          #include "usb_midi.h"
  24          
  25          /*
  26           * Global buffer for the OUT endpoint.
  27           */
  28          SI_SEGMENT_VARIABLE(midiInMsg, MIDI_Event_Packet_t, SI_SEG_XDATA);
  29          // flag indicating a new event.
  30          bit newInEvent;
  31          
  32          //-----------------------------------------------------------------------------
  33          // SiLabs_Startup() Routine
  34          // ----------------------------------------------------------------------------
  35          // This function is called immediately after reset, before the initialization
  36          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  37          // useful place to disable the watchdog timer, which is enable by default
  38          // and may trigger before main() in some instances.
  39          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/17/2019 17:13:50 PAGE 2   

  40          void SiLabs_Startup(void) {
  41   1              // $[SiLabs Startup]
  42   1              // [SiLabs Startup]$
  43   1      }
  44          
  45          /*
  46           * Structure which holds joystick and button-press information.
  47           * Yes, it's an HID report structure.
  48           */
  49          struct joystickReportData {
  50                  uint8_t Button; /**< Button mask for currently pressed buttons in the game pad. */
  51                  uint8_t X;
  52                  uint8_t Y;
  53          } joystickReportData;
  54          
  55          //-----------------------------------------------------------------------------
  56          // CreateJoystickReport() Routine
  57          // ----------------------------------------------------------------------------
  58          //
  59          // Description - Generate joystick status report according Joystick and Button
  60          //               status.
  61          //
  62          //-----------------------------------------------------------------------------
  63          void CreateJoystickReport(void) {
  64   1              uint8_t joyStatus = Joystick_GetStatus();
  65   1      
  66   1              memset(&joystickReportData, 0, sizeof(joystickReportData));
  67   1      
  68   1              if (joyStatus & JOY_UP) {
  69   2                      joystickReportData.Y = 0x7F;
  70   2              } else if (joyStatus & JOY_DOWN) {
  71   2                      joystickReportData.Y = 0x01;
  72   2              }
  73   1      
  74   1              if (joyStatus & JOY_LEFT) {
  75   2                      joystickReportData.X = 0x01;
  76   2              } else if (joyStatus & JOY_RIGHT) {
  77   2                      joystickReportData.X = 0x7F;
  78   2              }
  79   1      
  80   1              joystickReportData.Button = joyStatus & BUTTON_MASK;
  81   1      }
  82          
  83          //-----------------------------------------------------------------------------
  84          // main() Routine
  85          // ----------------------------------------------------------------------------
  86          int main(void) {
  87   1      //      static SI_SEGMENT_VARIABLE(line[DISP_BUF_SIZE], uint8_t, RENDER_LINE_SEG);
  88   1      //      uint8_t y;
  89   1      //      uint16_t lastTick;
  90   1              MIDI_Event_Packet_t mep;
  91   1              bit LBState;
  92   1              bit RBState;
  93   1              bool usbIntsEnabled;
  94   1      
  95   1              // Call hardware initialization routine
  96   1              enter_DefaultMode_from_RESET();
  97   1      #if 0
                      DISP_Init();
                      lastTick = GetTickCount();
              
                      for (y = 0; y < FONT_HEIGHT; y++) {
                              RENDER_ClrLine (line);
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/17/2019 17:13:50 PAGE 3   

                              RENDER_StrLine(line, 3, y, "TEST");
                              DISP_WriteLine(4 + y, line);
                      }
              #endif
 107   1      
 108   1              LBState = 0;
 109   1              RBState = 0;
 110   1              newInEvent = 0;
 111   1      
 112   1              while (1) {
 113   2      // $[Generated Run-time code]
 114   2      // [Generated Run-time code]$
 115   2      #if 0
                              for (y = 0; y < FONT_HEIGHT; y++) {
                                      RENDER_ClrLine (line);
                                      RENDER_StrLine(line, 3, y, "TEST");
                                      DISP_WriteLine(4 + y, line);
                              }
              #endif
 122   2                      // check the joystick and buttons for changes.
 123   2                      CreateJoystickReport();
 124   2      
 125   2                      // for now, if a button was pressed, send a Control Change message on MIDI channel 3.
 126   2                      if (joystickReportData.Button == LEFT_BUTTON) {
 127   3                              mep.event = 0x0B;               // CC on channel 1
 128   3                              mep.byte1 = 0xB0;
 129   3                              mep.byte2 = 80;
 130   3                              RGB_CEX_BLUE = 0x00;
 131   3                              RGB_CEX_GREEN = 0x00;
 132   3                              if (LBState == 0) {
 133   4                                      RGB_CEX_RED = 0x7F;
 134   4                                      mep.byte3 = 0x7F;               // full
 135   4                              } else {
 136   4                                      RGB_CEX_RED = 0x00;
 137   4                                      mep.byte3 = 0x00;
 138   4                              }
 139   3                              LBState = !LBState;
 140   3                              usbIntsEnabled = USB_GetIntsEnabled();
 141   3                              USB_DisableInts();
 142   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
 143   3                              if (usbIntsEnabled)
 144   3                                      USB_EnableInts();
 145   3                      } // Left Button
 146   2      
 147   2                      if (joystickReportData.Button == RIGHT_BUTTON) {
 148   3                              mep.event = 0x0B;               // CC on channel 1
 149   3                              mep.byte1 = 0xB0;               // CC on channel 1
 150   3                              mep.byte2 = 81;
 151   3                              RGB_CEX_BLUE = 0x00;
 152   3                              RGB_CEX_RED = 0x00;
 153   3                              if (RBState == 0) {
 154   4                                      RGB_CEX_GREEN = 0x7F;
 155   4                                      mep.byte3 = 0x7F;               // full
 156   4                              } else {
 157   4                                      RGB_CEX_GREEN = 0x00;
 158   4                                      mep.byte3 = 0x00;
 159   4                              }
 160   3                              RBState = !RBState;
 161   3                              usbIntsEnabled = USB_GetIntsEnabled();
 162   3                              USB_DisableInts();
 163   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
 164   3                              if (usbIntsEnabled)
 165   3                                      USB_EnableInts();
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/17/2019 17:13:50 PAGE 4   

 166   3                      } // Right Button
 167   2      
 168   2                      if (joystickReportData.X) {
 169   3                              RGB_CEX_RED = 0x00;
 170   3                              RGB_CEX_GREEN = 0x00;
 171   3                              mep.event = 0x0B;               // CC on channel 1
 172   3                              mep.byte1 = 0xB0;               // CC on channel 1
 173   3                              mep.byte2 = 82;
 174   3                              mep.byte3 = joystickReportData.X;
 175   3                              RGB_CEX_BLUE = joystickReportData.X;
 176   3                              usbIntsEnabled = USB_GetIntsEnabled();
 177   3                              USB_DisableInts();
 178   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
 179   3                              if (usbIntsEnabled)
 180   3                                      USB_EnableInts();
 181   3                      } // Joystick X
 182   2      
 183   2                      if (joystickReportData.Y) {
 184   3                              RGB_CEX_RED = 0x00;
 185   3                              RGB_CEX_GREEN = 0x00;
 186   3                              mep.event = 0x0B;               // CC on channel 1
 187   3                              mep.byte1 = 0xB0;               // CC on channel 1
 188   3                              mep.byte2 = 83;
 189   3                              mep.byte3 = joystickReportData.Y;
 190   3                              RGB_CEX_BLUE = joystickReportData.Y;
 191   3                              usbIntsEnabled = USB_GetIntsEnabled();
 192   3                              USB_DisableInts();
 193   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
 194   3                              if (usbIntsEnabled)
 195   3                                      USB_EnableInts();
 196   3                      } // Joystick X
 197   2      #if 1
 198   2                      // Try to read from the OUT endpoint.
 199   2                      if (!USBD_EpIsBusy(EP1OUT) && (USBD_GetUsbState() == USBD_STATE_CONFIGURED)) {
 200   3                               USBD_Read(
 201   3                                              EP1OUT,
 202   3                                              (uint8_t *) &midiInMsg,
 203   3                                              sizeof(MIDI_Event_Packet_t), // midi messages are four bytes
 204   3                                              true);
 205   3                      }
 206   2      
 207   2                      // did we get a new event?
 208   2                      if (newInEvent) {
 209   3                              newInEvent = 0;
 210   3                              if (midiInMsg.byte1 == 0xB0) {
 211   4                                      switch (midiInMsg.byte2) {
 212   5                                      case 80 : // left button
 213   5                                              RGB_CEX_GREEN = midiInMsg.byte3 << 1;
 214   5                                              RGB_CEX_RED = 0;
 215   5                                              RGB_CEX_BLUE = 0;
 216   5                                              break;
 217   5                                      case 81 : // right button
 218   5                                              RGB_CEX_GREEN = 0;
 219   5                                              RGB_CEX_RED = midiInMsg.byte3 << 1;
 220   5                                              RGB_CEX_BLUE = 0;
 221   5                                              break;
 222   5                                      case 82 : // joystick X
 223   5                                              RGB_CEX_GREEN = 0;
 224   5                                              RGB_CEX_RED = 0;
 225   5                                              RGB_CEX_BLUE = midiInMsg.byte3 << 1;
 226   5                                              break;
 227   5                                      case 83 : // joystick Y
 228   5                                              RGB_CEX_GREEN = 0; //midiInMsg.byte3 << 1;
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/17/2019 17:13:50 PAGE 5   

 229   5                                              RGB_CEX_RED = 0;
 230   5                                              RGB_CEX_BLUE = midiInMsg.byte3 << 1;
 231   5                                              break;
 232   5                                      } // switch
 233   4                              } // event
 234   3                      } // newInEvent
 235   2      #endif
 236   2      
 237   2              } // main while(1) loop
 238   1      } // main()


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    533    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
