C51 COMPILER V9.53.0.0   ADC_0                                                             04/17/2019 17:13:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE ADC_0
OBJECT MODULE PLACED IN .\lib\efm8ub2\peripheralDrivers\src\adc_0.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\apeters
                    -.SPECSERV\Projects\EFM8-USB-MIDI\lib\efm8ub2\peripheralDrivers\src\adc_0.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\apeters.SPECSER
                    -V\Projects\EFM8-USB-MIDI\inc;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\inc\config;C:\Users\apeters.SPECSERV\Proje
                    -cts\EFM8-USB-MIDI\usb_audio\inc;${workspace_loc:/;${workspace_loc:/;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib
                    -\bsp\efm8_memory_lcd\inc;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_memory_lcd\inc\config;${workspace
                    -_loc:/;${workspace_loc:/C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_joystick;${workspace_loc:/C:\Users
                    -\apeters.SPECSERV\Projects\EFM8-USB-MIDI\lib\bsp\efm8_rgb_led;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.
                    -1.6//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/inc;C:/Silic
                    -onLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Lib/efm8_usb/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdk
                    -s/8051/v4.1.6//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_j
                    -oystick;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc;C:/Silico
                    -nLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/graphics;C:/SiliconLabs/Si
                    -mplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/config;C:/SiliconLabs/SimplicitySt
                    -udio/v4/developer/sdks/8051/v4.1.6//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/
                    -EFM8UB2_SLSTK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_rgb_le
                    -d;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/peripheral_driver/inc) PRINT(.\lib\efm8u
                    -b2\peripheralDrivers\src\adc_0.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\lib\efm8ub2\peripheralDrivers\src\adc
                    -_0.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "adc_0.h"
   8          #include "assert.h"
   9          
  10          #if EFM8PDL_ADC0_AUTO_PAGE == 1
  11          // declare variable needed for autopage enter/exit
  12          #define DECL_PAGE uint8_t savedPage
  13          // enter autopage section
  14          #define SET_PAGE(p)     do                                                    \
  15                                  {                                                     \
  16                                    savedPage = SFRPAGE;  /* save current SFR page */   \
  17                                    SFRPAGE = (p);        /* set SFR page */            \
  18                                  } while(0)
  19          // exit autopage section
  20          #define RESTORE_PAGE    do                                                    \
  21                                  {                                                     \
  22                                    SFRPAGE = savedPage;  /* restore saved SFR page */  \
  23                                  } while(0)
  24          #else
              #define DECL_PAGE
              #define SET_PAGE(p)
              #define RESTORE_PAGE
              #endif
  29           
  30          #define ADC0_SFRPAGE 0x00        
  31          #define ADC0_enableTempSensor()   REF0CN |= 0x04
  32          #define ADC0_disableTempSensor()  REF0CN &= 0xFB
  33          
  34          #if EFM8PDL_ADC0_USE_INIT == 1
  35          #define MAX_SARCLK  8333333UL
  36          #define MAX_SYSCLK 48000000UL
  37           
  38          void ADC0_init(ADC0_ConversionStart_t convStart,
C51 COMPILER V9.53.0.0   ADC_0                                                             04/17/2019 17:13:50 PAGE 2   

  39                          uint32_t sysclk)
  40          {
  41   1              uint8_t divider;
  42   1              DECL_PAGE;
  43   1              SET_PAGE(ADC0_SFRPAGE);
  44   1      
  45   1              // Sysclk cannot be greater than the maximum
  46   1              SLAB_ASSERT(sysclk <= MAX_SYSCLK);
  47   1      
  48   1          // calculate SAR clock divider 
  49   1          divider = 0; 
  50   1        while(sysclk > MAX_SARCLK * (divider + 1))
  51   1        {
  52   2          divider++;
  53   2        }
  54   1      
  55   1              ADC0CF = divider << ADC0CF_ADSC__SHIFT | ADC0CF_ADLJST__RIGHT_JUSTIFIED;
  56   1              ADC0CN0 = convStart; 
  57   1      
  58   1              // Enable ADC
  59   1              ADC0CN0_ADEN = 1;
  60   1              RESTORE_PAGE;
  61   1      }
  62          #endif //EFM8PDL_ADC0_USE_INIT
  63          
  64          uint8_t ADC0_getIntFlags()
  65          {
  66   1        uint8_t val;
  67   1        DECL_PAGE;
  68   1        SET_PAGE(ADC0_SFRPAGE);
  69   1        val = ADC0CN0 & (ADC0_CONVERSION_COMPLETE_IF | ADC0_WINDOW_COMPARE_IF);
  70   1        RESTORE_PAGE;
  71   1        return val;
  72   1      }
  73          
  74          void ADC0_clearIntFlags(uint8_t flags)
  75          {
  76   1        DECL_PAGE;
  77   1        SET_PAGE(ADC0_SFRPAGE);
  78   1       
  79   1        // Must pass one of the valid flags
  80   1        SLAB_ASSERT(flags & (ADC0_CONVERSION_COMPLETE_IF | ADC0_WINDOW_COMPARE_IF));
  81   1      
  82   1        ADC0CN0 &= ~(flags & (ADC0_CONVERSION_COMPLETE_IF | ADC0_WINDOW_COMPARE_IF));
  83   1        RESTORE_PAGE;
  84   1      }
  85          
  86          void ADC0_enableInt(uint8_t flags, bool enable)
  87          {
  88   1        uint8_t en;
  89   1        DECL_PAGE;
  90   1        SET_PAGE(0x00);
  91   1      
  92   1        // Must pass one of the valid flags
  93   1        SLAB_ASSERT(flags & (ADC0_CONVERSION_COMPLETE_IF | ADC0_WINDOW_COMPARE_IF));
  94   1      
  95   1        en = (uint8_t) enable;
  96   1      
  97   1        if (flags & ADC0_CONVERSION_COMPLETE_IF)
  98   1        {
  99   2          EIE1 &= ~EIE1_EADC0__BMASK;
 100   2          EIE1 |= en << EIE1_EADC0__SHIFT;
 101   2        }
C51 COMPILER V9.53.0.0   ADC_0                                                             04/17/2019 17:13:50 PAGE 3   

 102   1      
 103   1        if (flags & ADC0_WINDOW_COMPARE_IF)
 104   1        {
 105   2          EIE1 &= ~EIE1_EWADC0__BMASK;
 106   2          EIE1 |= en << EIE1_EWADC0__SHIFT;
 107   2        }
 108   1        RESTORE_PAGE;
 109   1      }
 110          
 111          
 112          void ADC0_enable(void)
 113          {
 114   1              DECL_PAGE;
 115   1              SET_PAGE(ADC0_SFRPAGE);
 116   1              ADC0CN0_ADEN = 1;
 117   1              RESTORE_PAGE;
 118   1      }
 119          
 120          void ADC0_disable(void)
 121          {
 122   1              DECL_PAGE;
 123   1              SET_PAGE(ADC0_SFRPAGE);
 124   1              ADC0CN0_ADEN = 0;
 125   1              RESTORE_PAGE;
 126   1      }
 127          
 128          void ADC0_setPositiveInput(ADC0_PositiveInput_t input)
 129          {
 130   1              DECL_PAGE;
 131   1              SET_PAGE(ADC0_SFRPAGE);
 132   1      
 133   1              // Turn on the temp sensor if it is the input
 134   1        if (input == ADC0_POSITIVE_INPUT_TEMP)
 135   1        {
 136   2          ADC0_enableTempSensor();
 137   2        }
 138   1        else
 139   1        {
 140   2          ADC0_disableTempSensor();
 141   2        }
 142   1       
 143   1              AMX0P = input;
 144   1              RESTORE_PAGE;
 145   1      }
 146          
 147          void ADC0_setNegativeInput(ADC0_NegativeInput_t input)
 148          {
 149   1              DECL_PAGE;
 150   1              SET_PAGE(ADC0_SFRPAGE);
 151   1      
 152   1              AMX0N = input;
 153   1              RESTORE_PAGE;
 154   1      }
 155          void ADC0_startConversion(void)
 156          {
 157   1              uint8_t ADCM_save;
 158   1              DECL_PAGE;
 159   1              SET_PAGE(ADC0_SFRPAGE);
 160   1      
 161   1              // Save the conversion source and set to ADBUSY
 162   1              ADCM_save = ADC0CN0 & ADC0CN0_ADCM__FMASK;
 163   1              ADC0CN0 = (ADC0CN0 & ~ADC0CN0_ADCM__FMASK) | ADC0CN0_ADCM__ADBUSY;
 164   1       
C51 COMPILER V9.53.0.0   ADC_0                                                             04/17/2019 17:13:50 PAGE 4   

 165   1              // Clear the conversion complete flag
 166   1              ADC0CN0_ADINT = 0;
 167   1      
 168   1              // Start a conversion by setting ADBUSY
 169   1              ADC0CN0_ADBUSY = 1;
 170   1      
 171   1              // Restore the conversion source
 172   1              ADC0CN0 |= ADCM_save;
 173   1              RESTORE_PAGE;
 174   1      }
 175          
 176          bool ADC0_isConversionComplete(void)
 177          {
 178   1              bool conversionComplete;
 179   1              DECL_PAGE;
 180   1              SET_PAGE(ADC0_SFRPAGE);
 181   1              conversionComplete = ADC0CN0_ADINT;
 182   1              RESTORE_PAGE;
 183   1              return conversionComplete;
 184   1      }
 185          
 186          uint16_t ADC0_getResult(void)
 187          {
 188   1              uint16_t result;
 189   1              DECL_PAGE;
 190   1              SET_PAGE(ADC0_SFRPAGE);
 191   1              result = ADC0;
 192   1              RESTORE_PAGE;
 193   1              return result;
 194   1      }
 195          
 196          void ADC0_setWindowCompare(uint16_t lessThan, uint16_t greaterThan)
 197          {
 198   1              DECL_PAGE;
 199   1              SET_PAGE(ADC0_SFRPAGE);
 200   1          ADC0LT = lessThan;
 201   1              ADC0GT = greaterThan;
 202   1              RESTORE_PAGE;
 203   1      }
 204          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    333    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
