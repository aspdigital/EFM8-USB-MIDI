//=========================================================
// src/EFM8-USB-MIDI_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

/*
 * NOTES!
 *
 * MIDI ports are the hardware or virtual connections.
 * This design has two in and two out ports.
 * Port 0 is the virtual port we use to control the hardware (for IN) and send back
 * 	button-and-knob changes.
 * Port 1 is the physical port connected to UART1.
 */

/*
 * Handling physical-port access. This uses the SiLab's Uart1 driver, and this
 * should probably be changed to something more general.
 *
 * USB MIDI OUT messages for port 1 are routed to UART1 for transmit.
 * The event part of the messages is stripped off and the three data bytes are
 * loaded into the UART's transmit buffer. The callback exists but isn't used
 * because it's not necessary.
 *
 * Messages received on physical port 1 in have an event byte added and a USB
 * MIDI message is built from what was received, and that message is written
 * to the MIDI bulk IN endpoint.
 */

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB2_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
// $[Generated Includes]
#include "efm8_usb.h"
// [Generated Includes]$
#include "rgb_led.h"
#include "bsp.h"
#include "disp.h"
#include "render.h"
#include "tick.h"
#include "joybutton.h"
#include "midi.h"
#include "usb_midi.h"
#include "midi_uart.h"

/*
 * Global buffer for the OUT endpoint.
 */
SI_SEGMENT_VARIABLE(midiInMsg, MIDI_Event_Packet_t, SI_SEG_XDATA);
// flag indicating a new event.
bit newInEvent;

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup(void) {
	// $[SiLabs Startup]
	// [SiLabs Startup]$
}

/* UART callbacks. UART1 is for the MIDI port. Perhaps this should be in a midi directory? */
void UART1_transmitCompleteCb(void) {

}

void UART1_receiveCompleteCb(void) {

}

/*
 * Structure which holds joystick and button-press information.
 * Yes, it's an HID report structure.
 */
struct joystickReportData {
	uint8_t Button; /**< Button mask for currently pressed buttons in the game pad. */
	uint8_t X;
	uint8_t Y;
} joystickReportData;

//-----------------------------------------------------------------------------
// CreateJoystickReport() Routine
// ----------------------------------------------------------------------------
//
// Description - Generate joystick status report according Joystick and Button
//               status.
//
//-----------------------------------------------------------------------------
void CreateJoystickReport(void) {
	uint8_t joyStatus = Joystick_GetStatus();

	memset(&joystickReportData, 0, sizeof(joystickReportData));

	if (joyStatus & JOY_UP) {
		joystickReportData.Y = 0x7F;
	} else if (joyStatus & JOY_DOWN) {
		joystickReportData.Y = 0x01;
	}

	if (joyStatus & JOY_LEFT) {
		joystickReportData.X = 0x01;
	} else if (joyStatus & JOY_RIGHT) {
		joystickReportData.X = 0x7F;
	}

	joystickReportData.Button = joyStatus & BUTTON_MASK;
}

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main(void) {
//	static SI_SEGMENT_VARIABLE(line[DISP_BUF_SIZE], uint8_t, RENDER_LINE_SEG);
//	uint8_t y;
//	uint16_t lastTick;
	MIDI_Event_Packet_t mep;		// MIDI events we write to the host
	uint8_t MsgToUart[3];			// MIDI messages we write to the serial transmitter
	uint8_t MsgToUartSize;			// how many bytes in that message?
	bit LBState;
	bit RBState;
	bool usbIntsEnabled;

	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();
#if 0
	DISP_Init();
	lastTick = GetTickCount();

	for (y = 0; y < FONT_HEIGHT; y++) {
		RENDER_ClrLine (line);
		RENDER_StrLine(line, 3, y, "TEST");
		DISP_WriteLine(4 + y, line);
	}
#endif

	LBState = 0;
	RBState = 0;
	newInEvent = 0;

	while (1) {
// $[Generated Run-time code]
// [Generated Run-time code]$
#if 0
		for (y = 0; y < FONT_HEIGHT; y++) {
			RENDER_ClrLine (line);
			RENDER_StrLine(line, 3, y, "TEST");
			DISP_WriteLine(4 + y, line);
		}
#endif
		// check the joystick and buttons for changes.
		CreateJoystickReport();

		// for now, if a button was pressed, send a Control Change message on MIDI channel 1.
		if (joystickReportData.Button == LEFT_BUTTON) {
			mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);		// CC on channel 1
			mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);	// CC on channel 1
			mep.byte2 = 80;
			RGB_CEX_BLUE = 0x00;
			RGB_CEX_GREEN = 0x00;
			if (LBState == 0) {
				RGB_CEX_RED = 0x7F;
				mep.byte3 = 0x7F;		// full
			} else {
				RGB_CEX_RED = 0x00;
				mep.byte3 = 0x00;
			}
			LBState = !LBState;
			usbIntsEnabled = USB_GetIntsEnabled();
			USB_DisableInts();
			USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
			if (usbIntsEnabled)
				USB_EnableInts();
		} // Left Button

		if (joystickReportData.Button == RIGHT_BUTTON) {
			mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
			mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);	// CC on channel 1
			mep.byte2 = 81;
			RGB_CEX_BLUE = 0x00;
			RGB_CEX_RED = 0x00;
			if (RBState == 0) {
				RGB_CEX_GREEN = 0x7F;
				mep.byte3 = 0x7F;		// full
			} else {
				RGB_CEX_GREEN = 0x00;
				mep.byte3 = 0x00;
			}
			RBState = !RBState;
			usbIntsEnabled = USB_GetIntsEnabled();
			USB_DisableInts();
			USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
			if (usbIntsEnabled)
				USB_EnableInts();
		} // Right Button

		if (joystickReportData.X) {
			RGB_CEX_RED = 0x00;
			RGB_CEX_GREEN = 0x00;
			mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
			mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);	// CC on channel 1
			mep.byte2 = 82;
			mep.byte3 = joystickReportData.X;
			RGB_CEX_BLUE = joystickReportData.X;
			usbIntsEnabled = USB_GetIntsEnabled();
			USB_DisableInts();
			USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
			if (usbIntsEnabled)
				USB_EnableInts();
		} // Joystick X

		if (joystickReportData.Y) {
			RGB_CEX_RED = 0x00;
			RGB_CEX_GREEN = 0x00;
			mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
			mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);	// CC on channel 1
			mep.byte2 = 83;
			mep.byte3 = joystickReportData.Y;
			RGB_CEX_BLUE = joystickReportData.Y;
			usbIntsEnabled = USB_GetIntsEnabled();
			USB_DisableInts();
			USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
			if (usbIntsEnabled)
				USB_EnableInts();
		} // Joystick X

		/*
		 * Try to read from the OUT endpoint.
		 * remember, this provides packets for ALL ports.
		 */

		if (!USBD_EpIsBusy(EP1OUT)) {
			USBD_Read(EP1OUT, (uint8_t *) &midiInMsg,
					sizeof(MIDI_Event_Packet_t), // midi messages are four bytes
					true);
		}

		// did we get a new event?
		if (newInEvent) {
			newInEvent = 0;

			// if it targets the hardware port, just pass it along.
			// We don't care much about the particular event, just the port (Cable Number).
			// the buffer is only three bytes because the USB packet can only give us
			// up to three bytes at a time.
			if (USB_MIDI_CABLE_NUMBER(midiInMsg.event) == UART_CN ) {
				MsgToUart[0] = midiInMsg.byte1;
				MsgToUart[1] = midiInMsg.byte2;
				MsgToUart[2] = midiInMsg.byte3;

				switch (USB_MIDI_CODE_INDEX_NUMBER(midiInMsg.event)) {
				case USB_MIDI_CIN_SYSEND1:
				case USB_MIDI_CIN_SINGLEBYTE :
					MsgToUartSize = 1;
					break;
				case USB_MIDI_CIN_SYSCOM2 :
				case USB_MIDI_CIN_SYSEND2 :
				case USB_MIDI_CIN_PROGCHANGE :
				case USB_MIDI_CIN_CHANPRESSURE :
					MsgToUartSize = 2;
					break;
				default :
					MsgToUartSize = 3;
					break;
				} // switch

				MIDIUART_writeMessage(MsgToUart, MsgToUartSize);

			} else if (USB_MIDI_CABLE_NUMBER(midiInMsg.event) == VIRTUAL_CN ) {

				if (midiInMsg.byte1 == MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0)) {
					switch (midiInMsg.byte2) {
					case 80: // left button
						RGB_CEX_GREEN = midiInMsg.byte3 << 1;
						RGB_CEX_RED = 0;
						RGB_CEX_BLUE = 0;
						break;
					case 81: // right button
						RGB_CEX_GREEN = 0;
						RGB_CEX_RED = midiInMsg.byte3 << 1;
						RGB_CEX_BLUE = 0;
						break;
					case 82: // joystick X
						RGB_CEX_GREEN = 0;
						RGB_CEX_RED = 0;
						RGB_CEX_BLUE = midiInMsg.byte3 << 1;
						break;
					case 83: // joystick Y
						RGB_CEX_GREEN = 0; //midiInMsg.byte3 << 1;
						RGB_CEX_RED = 0;
						RGB_CEX_BLUE = midiInMsg.byte3 << 1;
						break;
					} // switch
				} // event
			} // which cable number?
		} // newInEvent

		/*
		 * Handle messages received on the hardware IN port.
		 * These get packetized by the serial receiver for sending to host on USB IN endpoint.
		 * We just pass along the packet.
		 */
		if (MIDIUART_readMessage(&mep) != 0) {
			usbIntsEnabled = USB_GetIntsEnabled();
			USB_DisableInts();
			USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), true);
			if (usbIntsEnabled)
				USB_EnableInts();
		}


	} // main while(1) loop
} // main()
