C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE EFM8_USB_MIDI_MAIN
OBJECT MODULE PLACED IN .\src/EFM8-USB-MIDI_main.OBJ
COMPILER INVOKED BY: Z:\Applications\Simplicity Studio.app\Contents\Eclipse\developer\toolchains\keil_8051\9.53\BIN\C51.
                    -exe /Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/src/EFM8-USB-MIDI_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM
                    -(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(/Users/andy/
                    -Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/inc/config;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/inc;/
                    -Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/midi;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/
                    -lib/efm8ub2/peripheralDrivers/inc;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/efm8ub2_slstk2001a/bsp;/
                    -Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/bsp;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MI
                    -DI/usb_audio/inc;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/efm8_usb/inc;/Users/andy/Projects/Workspa
                    -ces/SiLabs_8051/EFM8-USB-MIDI/lib/efm8_assert;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/bsp/efm8_mem
                    -ory_lcd/inc;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/bsp/efm8_memory_lcd/inc/config;/Users/andy/Pro
                    -jects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/bsp/efm8_memory_lcd/inc/graphics;/Users/andy/Projects/Workspaces/SiLabs_8
                    -051/EFM8-USB-MIDI/lib/bsp/efm8_joystick;/Users/andy/Projects/Workspaces/SiLabs_8051/EFM8-USB-MIDI/lib/bsp/efm8_rgb_led;/
                    -Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.1.6//Device/shared/si8051Base;/Applications/S
                    -implicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.1.6//Device/EFM8UB2/inc) PRINT(.\src/EFM8-USB-MIDI_main.lst
                    -) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src/EFM8-USB-MIDI_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/EFM8-USB-MIDI_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          /*
  10           * NOTES!
  11           *
  12           * MIDI ports are the hardware or virtual connections.
  13           * This design has two in and two out ports.
  14           * Port 0 is the virtual port we use to control the hardware (for IN) and send back
  15           *      button-and-knob changes.
  16           * Port 1 is the physical port connected to UART1.
  17           */
  18          
  19          /*
  20           * Handling physical-port access. This uses the SiLab's Uart1 driver, and this
  21           * should probably be changed to something more general.
  22           *
  23           * USB MIDI OUT messages for port 1 are routed to UART1 for transmit.
  24           * The event part of the messages is stripped off and the three data bytes are
  25           * loaded into the UART's transmit buffer. The callback exists but isn't used
  26           * because it's not necessary.
  27           *
  28           * Messages received on physical port 1 in have an event byte added and a USB
  29           * MIDI message is built from what was received, and that message is written
  30           * to the MIDI bulk IN endpoint.
  31           */
  32          
  33          //-----------------------------------------------------------------------------
  34          // Includes
  35          //-----------------------------------------------------------------------------
  36          #include <SI_EFM8UB2_Register_Enums.h>                  // SFR declarations
  37          #include "InitDevice.h"
  38          // $[Generated Includes]
  39          #include "efm8_usb.h"
  40          // [Generated Includes]$
  41          #include "rgb_led.h"
  42          #include "bsp.h"
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 2   

  43          #include "disp.h"
  44          #include "render.h"
  45          #include "tick.h"
  46          #include "joybutton.h"
  47          #include "midi.h"
  48          #include "usb_midi.h"
  49          #include "midi_uart.h"
  50          
  51          /*
  52           * Global buffers for the OUT endpoint.
  53           * One buffer is used for the USBD_Read() and the callback.
  54           * The other buffer is used for parsing the message. The contents of the
  55           * first buffer are copied into it in the transfer-complete callback.
  56           */
  57          
  58          // this buffer is used for the USBD_Read().
  59          SI_SEGMENT_VARIABLE(EndpointBuffer, MIDI_Event_Packet_t, SI_SEG_XDATA);
  60          // this buffer is filled by the callback with the contents of midiInReadMsg:
  61          SI_SEGMENT_VARIABLE(midiUsbOutPacket, MIDI_Event_Packet_t, SI_SEG_XDATA);
  62          // flag indicating a new packet, set in the callback for the EP1 OUT interrupt.
  63          volatile bit newIncomingPacket;
  64          
  65          //-----------------------------------------------------------------------------
  66          // SiLabs_Startup() Routine
  67          // ----------------------------------------------------------------------------
  68          // This function is called immediately after reset, before the initialization
  69          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  70          // useful place to disable the watchdog timer, which is enable by default
  71          // and may trigger before main() in some instances.
  72          //-----------------------------------------------------------------------------
  73          void SiLabs_Startup(void) {
  74   1              // $[SiLabs Startup]
  75   1              // [SiLabs Startup]$
  76   1      }
  77          
  78          /* UART callbacks. UART1 is for the MIDI port. Perhaps this should be in a midi directory? */
  79          void UART1_transmitCompleteCb(void) {
  80   1      
  81   1      }
  82          
  83          void UART1_receiveCompleteCb(void) {
  84   1      
  85   1      }
  86          
  87          /*
  88           * Structure which holds joystick and button-press information.
  89           * Yes, it's an HID report structure.
  90           */
  91          struct joystickReportData {
  92                  uint8_t Button; /**< Button mask for currently pressed buttons in the game pad. */
  93                  uint8_t X;
  94                  uint8_t Y;
  95          } joystickReportData;
  96          
  97          //-----------------------------------------------------------------------------
  98          // CreateJoystickReport() Routine
  99          // ----------------------------------------------------------------------------
 100          //
 101          // Description - Generate joystick status report according Joystick and Button
 102          //               status.
 103          //
 104          //-----------------------------------------------------------------------------
 105          void CreateJoystickReport(void) {
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 3   

 106   1              uint8_t joyStatus = Joystick_GetStatus();
 107   1      
 108   1              memset(&joystickReportData, 0, sizeof(joystickReportData));
 109   1      
 110   1              if (joyStatus & JOY_UP) {
 111   2                      joystickReportData.Y = 0x7F;
 112   2              } else if (joyStatus & JOY_DOWN) {
 113   2                      joystickReportData.Y = 0x01;
 114   2              }
 115   1      
 116   1              if (joyStatus & JOY_LEFT) {
 117   2                      joystickReportData.X = 0x01;
 118   2              } else if (joyStatus & JOY_RIGHT) {
 119   2                      joystickReportData.X = 0x7F;
 120   2              }
 121   1      
 122   1              joystickReportData.Button = joyStatus & BUTTON_MASK;
 123   1      }
 124          
 125          //-----------------------------------------------------------------------------
 126          // main() Routine
 127          // ----------------------------------------------------------------------------
 128          int main(void) {
 129   1      //      static SI_SEGMENT_VARIABLE(line[DISP_BUF_SIZE], uint8_t, RENDER_LINE_SEG);
 130   1      //      uint8_t y;
 131   1      //      uint16_t lastTick;
 132   1              MIDI_Event_Packet_t mep;                // MIDI events we write to the host
 133   1              uint8_t MsgToUart[3];   // MIDI messages we write to the serial transmitter
 134   1              uint8_t MsgToUartSize;                  // how many bytes in that message?
 135   1              bit LBState;
 136   1              bit RBState;
 137   1              bool usbIntsEnabled;
 138   1      
 139   1              // Call hardware initialization routine
 140   1              enter_DefaultMode_from_RESET();
 141   1      #if 0
                      DISP_Init();
                      lastTick = GetTickCount();
              
                      for (y = 0; y < FONT_HEIGHT; y++) {
                              RENDER_ClrLine (line);
                              RENDER_StrLine(line, 3, y, "TEST");
                              DISP_WriteLine(4 + y, line);
                      }
              #endif
 151   1      
 152   1              LBState = 0;
 153   1              RBState = 0;
 154   1              newIncomingPacket = 0;
 155   1      
 156   1              MIDIUART_init();
 157   1              /*
 158   1               * Prepare for the first USB packet with a MIDI message.
 159   1               * Remember, this provides packets for ALL ports.
 160   1               */
 161   1      
 162   1              USBD_Read(EP1OUT, (uint8_t *) &EndpointBuffer,
 163   1                                      sizeof(MIDI_Event_Packet_t), // midi messages are four bytes
 164   1                                      true); // we need the transfer-complete callback.
 165   1      
 166   1              while (1) {
 167   2      // $[Generated Run-time code]
 168   2      // [Generated Run-time code]$
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 4   

 169   2      #if 0
                              for (y = 0; y < FONT_HEIGHT; y++) {
                                      RENDER_ClrLine (line);
                                      RENDER_StrLine(line, 3, y, "TEST");
                                      DISP_WriteLine(4 + y, line);
                              }
              #endif
 176   2                      // check the joystick and buttons for changes.
 177   2                      CreateJoystickReport();
 178   2      
 179   2                      // for now, if a button was pressed, send a Control Change message on MIDI channel 1.
 180   2                      if (joystickReportData.Button == LEFT_BUTTON) {
 181   3                              mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);// CC on channel 1
 182   3                              mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);// CC on channel 1
 183   3                              mep.byte2 = 80;
 184   3                              RGB_CEX_BLUE = 0x00;
 185   3                              RGB_CEX_GREEN = 0x00;
 186   3                              if (LBState == 0) {
 187   4                                      RGB_CEX_RED = 0x7F;
 188   4                                      mep.byte3 = 0x7F;               // full
 189   4                              } else {
 190   4                                      RGB_CEX_RED = 0x00;
 191   4                                      mep.byte3 = 0x00;
 192   4                              }
 193   3                              LBState = !LBState;
 194   3                              usbIntsEnabled = USB_GetIntsEnabled();
 195   3                              USB_DisableInts();
 196   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), false);
 197   3                              if (usbIntsEnabled)
 198   3                                      USB_EnableInts();
 199   3                      } // Left Button
 200   2      
 201   2                      if (joystickReportData.Button == RIGHT_BUTTON) {
 202   3                              mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
 203   3                              mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);// CC on channel 1
 204   3                              mep.byte2 = 81;
 205   3                              RGB_CEX_BLUE = 0x00;
 206   3                              RGB_CEX_RED = 0x00;
 207   3                              if (RBState == 0) {
 208   4                                      RGB_CEX_GREEN = 0x7F;
 209   4                                      mep.byte3 = 0x7F;               // full
 210   4                              } else {
 211   4                                      RGB_CEX_GREEN = 0x00;
 212   4                                      mep.byte3 = 0x00;
 213   4                              }
 214   3                              RBState = !RBState;
 215   3                              usbIntsEnabled = USB_GetIntsEnabled();
 216   3                              USB_DisableInts();
 217   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), false);
 218   3                              if (usbIntsEnabled)
 219   3                                      USB_EnableInts();
 220   3                      } // Right Button
 221   2      
 222   2                      if (joystickReportData.X) {
 223   3                              RGB_CEX_RED = 0x00;
 224   3                              RGB_CEX_GREEN = 0x00;
 225   3                              mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
 226   3                              mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);// CC on channel 1
 227   3                              mep.byte2 = 82;
 228   3                              mep.byte3 = joystickReportData.X;
 229   3                              RGB_CEX_BLUE = joystickReportData.X;
 230   3                              usbIntsEnabled = USB_GetIntsEnabled();
 231   3                              USB_DisableInts();
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 5   

 232   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), false);
 233   3                              if (usbIntsEnabled)
 234   3                                      USB_EnableInts();
 235   3                      } // Joystick X
 236   2      
 237   2                      if (joystickReportData.Y) {
 238   3                              RGB_CEX_RED = 0x00;
 239   3                              RGB_CEX_GREEN = 0x00;
 240   3                              mep.event = USB_MIDI_EVENT(VIRTUAL_CN, USB_MIDI_CIN_CTRLCHANGE);
 241   3                              mep.byte1 = MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0);// CC on channel 1
 242   3                              mep.byte2 = 83;
 243   3                              mep.byte3 = joystickReportData.Y;
 244   3                              RGB_CEX_BLUE = joystickReportData.Y;
 245   3                              usbIntsEnabled = USB_GetIntsEnabled();
 246   3                              USB_DisableInts();
 247   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), false);
 248   3                              if (usbIntsEnabled)
 249   3                                      USB_EnableInts();
 250   3                      } // Joystick X
 251   2      
 252   2      
 253   2                      // did we get a new event?
 254   2                      if (newIncomingPacket) {
 255   3                              newIncomingPacket = 0;
 256   3      
 257   3                              // if it targets the hardware port, just pass it along.
 258   3                              // We don't care much about the particular event, just the port (Cable Number).
 259   3                              // the buffer is only three bytes because the USB packet can only give us
 260   3                              // up to three bytes at a time.
 261   3                              if (USB_MIDI_CABLE_NUMBER(midiUsbOutPacket.event) == UART_CN) {
 262   4                                      MsgToUart[0] = midiUsbOutPacket.byte1;
 263   4                                      MsgToUart[1] = midiUsbOutPacket.byte2;
 264   4                                      MsgToUart[2] = midiUsbOutPacket.byte3;
 265   4      
 266   4                                      switch (USB_MIDI_CODE_INDEX_NUMBER(midiUsbOutPacket.event)) {
 267   5                                      case USB_MIDI_CIN_SYSEND1:
 268   5                                      case USB_MIDI_CIN_SINGLEBYTE:
 269   5                                              MsgToUartSize = 1;
 270   5                                              break;
 271   5                                      case USB_MIDI_CIN_SYSCOM2:
 272   5                                      case USB_MIDI_CIN_SYSEND2:
 273   5                                      case USB_MIDI_CIN_PROGCHANGE:
 274   5                                      case USB_MIDI_CIN_CHANPRESSURE:
 275   5                                              MsgToUartSize = 2;
 276   5                                              break;
 277   5                                      default:
 278   5                                              MsgToUartSize = 3;
 279   5                                              break;
 280   5                                      } // switch
 281   4      
 282   4                                      MIDIUART_writeMessage(MsgToUart, MsgToUartSize);
 283   4      
 284   4                              } else if (USB_MIDI_CABLE_NUMBER(midiUsbOutPacket.event) == VIRTUAL_CN) {
 285   4      
 286   4                                      if (midiUsbOutPacket.byte1
 287   4                                                      == MIDI_STATUS_BYTE(MIDI_MSG_CTRLCHANGE, 0)) {
 288   5                                              switch (midiUsbOutPacket.byte2) {
 289   6                                              case 80: // left button
 290   6                                                      RGB_CEX_GREEN = midiUsbOutPacket.byte3 << 1;
 291   6                                                      RGB_CEX_RED = 0;
 292   6                                                      RGB_CEX_BLUE = 0;
 293   6                                                      break;
 294   6                                              case 81: // right button
C51 COMPILER V9.53.0.0   EFM8_USB_MIDI_MAIN                                                04/24/2019 21:26:44 PAGE 6   

 295   6                                                      RGB_CEX_GREEN = 0;
 296   6                                                      RGB_CEX_RED = midiUsbOutPacket.byte3 << 1;
 297   6                                                      RGB_CEX_BLUE = 0;
 298   6                                                      break;
 299   6                                              case 82: // joystick X
 300   6                                                      RGB_CEX_GREEN = 0;
 301   6                                                      RGB_CEX_RED = 0;
 302   6                                                      RGB_CEX_BLUE = midiUsbOutPacket.byte3 << 1;
 303   6                                                      break;
 304   6                                              case 83: // joystick Y
 305   6                                                      RGB_CEX_GREEN = 0; //midiInMsg.byte3 << 1;
 306   6                                                      RGB_CEX_RED = 0;
 307   6                                                      RGB_CEX_BLUE = midiUsbOutPacket.byte3 << 1;
 308   6                                                      break;
 309   6                                              } // switch
 310   5                                      } // event
 311   4                              } // which cable number?
 312   3                      } // newInEvent
 313   2      
 314   2                      /*
 315   2                       * Handle messages received on the hardware IN port.
 316   2                       * These get packetized by the serial receiver for sending to host on USB IN endpoint.
 317   2                       * We just pass along the packet.
 318   2                       */
 319   2                      if (MIDIUART_readMessage(&mep) != 0) {
 320   3                              usbIntsEnabled = USB_GetIntsEnabled();
 321   3                              USB_DisableInts();
 322   3                              USBD_Write(EP1IN, (uint8_t *) &mep, sizeof(mep), false);
 323   3                              if (usbIntsEnabled)
 324   3                                      USB_EnableInts();
 325   3                      }
 326   2      
 327   2              } // main while(1) loop
 328   1      } // main()


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    669    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
