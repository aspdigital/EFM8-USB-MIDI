C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE PCA_0
OBJECT MODULE PLACED IN .\lib\efm8ub2\peripheralDrivers\src\pca_0.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\apeters
                    -.SPECSERV\Projects\EFM8-USB-MIDI\lib\efm8ub2\peripheralDrivers\src\pca_0.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\apeters.SPECSER
                    -V\Projects\EFM8-USB-MIDI\inc;C:\Users\apeters.SPECSERV\Projects\EFM8-USB-MIDI\inc\config;C:\Users\apeters.SPECSERV\Proje
                    -cts\EFM8-USB-MIDI\usb_audio\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/peripheral
                    -_driver/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityS
                    -tudio/v4/developer/sdks/8051/v4.1.6//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.
                    -1.6//Lib/efm8_usb/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//Lib/efm8_assert;C:/SiliconLabs/Simp
                    -licityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_joystick;C:/SiliconLabs/SimplicityStudio/v4/develop
                    -er/sdks/8051/v4.1.6//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/EFM8UB2_SLSTK20
                    -01A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc;C:/Sil
                    -iconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/graphics;C:/SiliconLabs
                    -/SimplicityStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_memory_lcd/inc/config;C:/SiliconLabs/Simplicit
                    -yStudio/v4/developer/sdks/8051/v4.1.6//kits/common/drivers/efm8_rgb_led) PRINT(.\lib\efm8ub2\peripheralDrivers\src\pca_0
                    -.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\lib\efm8ub2\peripheralDrivers\src\pca_0.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "pca_0.h"
   8          
   9          #include "assert.h"
  10          
  11          uint8_t PCA0_getIntFlags()
  12          {
  13   1        return PCA0CN0 & (PCA0_OVERFLOW_IF
  14   1                          | PCA0_CHAN0_IF
  15   1                          | PCA0_CHAN1_IF
  16   1                          | PCA0_CHAN2_IF
  17   1                          | PCA0_CHAN3_IF
  18   1                          | PCA0_CHAN4_IF);
  19   1      }
  20          
  21          void PCA0_clearIntFlags(uint8_t flag)
  22          {
  23   1        PCA0CN0 &= ~flag;
  24   1      }
  25          
  26          void PCA0_enableInt(uint8_t flag, bool enable)
  27          {
  28   1        uint8_t en = (uint8_t) enable;
  29   1      
  30   1        if(flag & PCA0_CHAN0_IF){
  31   2          PCA0CPM0 &= ~PCA0CPM0_ECCF__BMASK;
  32   2          PCA0CPM0 |= en << PCA0CPM0_ECCF__SHIFT;
  33   2        }
  34   1        if(flag & PCA0_CHAN1_IF){
  35   2          PCA0CPM1 &= ~PCA0CPM1_ECCF__BMASK;
  36   2          PCA0CPM1 |= en << PCA0CPM1_ECCF__SHIFT;
  37   2        }
  38   1        if(flag & PCA0_CHAN2_IF){
  39   2          PCA0CPM2 &= ~PCA0CPM2_ECCF__BMASK;
  40   2          PCA0CPM2 |= en << PCA0CPM2_ECCF__SHIFT;
  41   2        }
  42   1        if(flag & PCA0_CHAN3_IF){
C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 2   

  43   2          PCA0CPM3 &= ~PCA0CPM3_ECCF__BMASK;
  44   2          PCA0CPM3 |= en << PCA0CPM3_ECCF__SHIFT;
  45   2        }
  46   1        if(flag & PCA0_CHAN4_IF){
  47   2          //Channel can not be modified when WDT enabled
  48   2          SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
  49   2          PCA0CPM4 &= ~PCA0CPM4_ECCF__BMASK;
  50   2          PCA0CPM4 |= en << PCA0CPM4_ECCF__SHIFT;
  51   2        }
  52   1        if(flag & PCA0_OVERFLOW_IF){
  53   2          PCA0MD &= ~PCA0MD_ECF__BMASK;
  54   2          PCA0MD |= en << PCA0MD_ECF__SHIFT;
  55   2        }
  56   1      }
  57          
  58          uint16_t PCA0_readChannel(PCA0_Channel_t channel)
  59          {
  60   1        switch(channel)
  61   1        {
  62   2        case 0:
  63   2          return PCA0CP0;
  64   2        case 1:
  65   2          return PCA0CP1;
  66   2        case 2:
  67   2          return PCA0CP2;
  68   2        case 3:
  69   2          return PCA0CP3;
  70   2        case 4:
  71   2          return PCA0CP4;
  72   2        }
  73   1        return 0x0;
  74   1      }
  75          
  76          void PCA0_writeChannel(PCA0_Channel_t channel, uint16_t value)
  77          {
  78   1        uint8_t lower = value >> 8;
  79   1        switch(channel)
  80   1        {
  81   2        case 0:
  82   2          //PCA0CP0 = value;
  83   2          PCA0CPL0 = value;
  84   2          PCA0CPH0 = lower;
  85   2          break;
  86   2        case 1:
  87   2          //PCA0CP1 = value;
  88   2          PCA0CPL1 = value;
  89   2          PCA0CPH1 = lower;
  90   2          break;
  91   2        case 2:
  92   2          //PCA0CP2 = value;
  93   2          PCA0CPL2 = value;
  94   2          PCA0CPH2 = lower;
  95   2          break;
  96   2        case 3:
  97   2          //PCA0CP3 = value;
  98   2          PCA0CPL3 = value;
  99   2          PCA0CPH3 = lower;
 100   2          break;
 101   2        case 4:
 102   2          //Timer can't be set when WDT enabled
 103   2          SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 104   2          //PCA0CP4 = value;
 105   2          PCA0CPL4 = value;
C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 3   

 106   2          PCA0CPH4 = lower;
 107   2          break;
 108   2        }
 109   1      }
 110          
 111          uint16_t PCA0_readCounter()
 112          {
 113   1        //PCA0L must be read first for accurate results. If PCA0
 114   1        //  is returned then PCA0H will be read first (compiler specific).
 115   1        // @todo: check that this actually reads pca0l first.
 116   1        return PCA0L + (PCA0H << 8);
 117   1      }
 118          
 119          void PCA0_writeCounter(uint16_t value)
 120          {
 121   1        //Timer can't be set when WDT enabled
 122   1        SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 123   1        PCA0 = value;
 124   1      }
 125          
 126          void PCA0_run()
 127          {
 128   1        //Counter/Timer can not stopped/started when WDT running
 129   1        SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 130   1        PCA0CN0_CR = 1;
 131   1      }
 132          
 133          void PCA0_halt()
 134          {
 135   1        //Counter/Timer can not stopped/started when WDT running
 136   1        SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 137   1        PCA0CN0_CR = 0;
 138   1      }
 139          
 140          void PCA0_init(PCA0_Timebase_t  timebase, PCA0_IdleState_t idleState)
 141          {
 142   1        //Counter/Timer can not be modified when WDT enabled
 143   1        SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 144   1        PCA0MD &= ~(PCA0MD_CPS__FMASK | PCA0MD_CIDL__BMASK);
 145   1        PCA0MD |= timebase + idleState;
 146   1      }
 147          
 148          void PCA0_initChannel(PCA0_Channel_t channel,
 149                                PCA0_ChannelMode_t  mode,
 150                                PCA0_ChannelOutPolatiry_t pol
 151                                )
 152          {
 153   1        #define MODE_MASK  ~(PCA0CPM0_PWM16__BMASK \
 154   1                             | PCA0CPM0_ECOM__BMASK \
 155   1                             | PCA0CPM0_CAPP__BMASK \
 156   1                             | PCA0CPM0_CAPN__BMASK \
 157   1                             | PCA0CPM0_MAT__BMASK \
 158   1                             | PCA0CPM0_TOG__BMASK \
 159   1                             | PCA0CPM0_PWM__BMASK)
 160   1        pol=pol;
 161   1      
 162   1        //Kill WDT mode if it is not the current target mode
 163   1        if(mode)
 164   1        {
 165   2          PCA0MD &= ~PCA0MD_WDTE__BMASK;
 166   2        }
 167   1      
 168   1        switch (channel)
C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 4   

 169   1        {
 170   2        case 0:
 171   2          PCA0CPM0 &= MODE_MASK;
 172   2          PCA0CPM0 |= mode;
 173   2          break;
 174   2      
 175   2        case 1:
 176   2          PCA0CPM1 &= MODE_MASK;
 177   2          PCA0CPM1 |= mode;
 178   2          break;
 179   2      
 180   2        case 2:
 181   2          PCA0CPM2 &= MODE_MASK;
 182   2          PCA0CPM2 |= mode;
 183   2          break;
 184   2      
 185   2        case 3:
 186   2          PCA0CPM3 &= MODE_MASK;
 187   2          PCA0CPM3 |= mode;
 188   2          break;
 189   2      
 190   2        case 4:
 191   2          //Channel 4 can not be modified when WDT enabled
 192   2          SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 193   2          PCA0CPM4 &= MODE_MASK;
 194   2          PCA0CPM4 |= mode;
 195   2          break;
 196   2        }
 197   1      
 198   1      }
 199          
 200          void PCA0_reset()
 201          {
 202   1        //Reset channels
 203   1        uint8_t i;
 204   1        for (i=0; i<=4; i++)
 205   1        {
 206   2          PCA0_resetChannel(i);
 207   2        }
 208   1      
 209   1        //Reset PCA regs
 210   1        PCA0MD = 0x0;
 211   1        PCA0CN0 = 0x0;
 212   1        PCA0   = 0x0;
 213   1      }
 214          
 215          void PCA0_resetChannel(PCA0_Channel_t channel)
 216          {
 217   1        switch (channel)
 218   1        {
 219   2        case 0:
 220   2          PCA0CP0 = 0x00;
 221   2          PCA0CPM0 = 0x0;
 222   2          return;
 223   2        case 1:
 224   2          PCA0CP1 = 0x00;
 225   2          PCA0CPM1 = 0x0;
 226   2          return;
 227   2        case 2:
 228   2          PCA0CP2 = 0x00;
 229   2          PCA0CPM2 = 0x0;
 230   2          return;
 231   2        case 3:
C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 5   

 232   2          PCA0CP3 = 0x00;
 233   2          PCA0CPM3 = 0x0;
 234   2          return;
 235   2        case 4:
 236   2          //Channel 4 can not be modified when WDT enabled
 237   2          SLAB_ASSERT(!(PCA0MD & PCA0MD_WDTE__BMASK));
 238   2          PCA0CP4 = 0x00;
 239   2          PCA0CPM4 = 0x0;
 240   2          return;
 241   2        }
 242   1      }
 243          
 244          #if EFM8PDL_PCA0_USE_ISR == 1
 245          
 246          //TODO: update to mask with interrupt enables.
 247          SI_INTERRUPT(PCA0_ISR, PCA0_IRQn)
 248          {
 249   1              //Save and clear flags
 250   1        uint8_t flags = PCA0CN0 & (PCA0CN0_CF__BMASK
 251   1                                   | PCA0CN0_CCF0__BMASK
 252   1                                   | PCA0CN0_CCF1__BMASK
 253   1                                   | PCA0CN0_CCF2__BMASK
 254   1                                   | PCA0CN0_CCF3__BMASK
 255   1                                   | PCA0CN0_CCF4__BMASK);
 256   1        PCA0CN0 &= ~flags;
 257   1      
 258   1        if((flags & PCA0CN0_CF__BMASK)
 259   1           && (PCA0MD & PCA0MD_ECF__BMASK))
 260   1        {
 261   2          PCA0_overflowCb();
 262   2        }
 263   1        if((flags & PCA0CN0_CCF0__BMASK)
 264   1           && (PCA0CPM0 & PCA0CPM0_ECCF__BMASK))
 265   1        {
 266   2          PCA0_channel0EventCb();
 267   2        }
 268   1        if((flags & PCA0CN0_CCF1__BMASK)
 269   1           && (PCA0CPM1 & PCA0CPM1_ECCF__BMASK))
 270   1        {
 271   2          PCA0_channel1EventCb();
 272   2        }
 273   1        if((flags & PCA0CN0_CCF2__BMASK)
 274   1           && (PCA0CPM2 & PCA0CPM2_ECCF__BMASK))
 275   1        {
 276   2          PCA0_channel2EventCb();
 277   2        }
 278   1        if((flags & PCA0CN0_CCF3__BMASK)
 279   1           && (PCA0CPM3 & PCA0CPM3_ECCF__BMASK))
 280   1        {
 281   2          PCA0_channel3EventCb();
 282   2        }
 283   1        if((flags & PCA0CN0_CCF4__BMASK)
 284   1           && (PCA0CPM4 & PCA0CPM4_ECCF__BMASK))
 285   1        {
 286   2          PCA0_channel4EventCb();
 287   2        }
 288   1      }
 289          
 290          #endif //EFM8PDL_PCA0_USE_CALLBACKS


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    750    ----
C51 COMPILER V9.53.0.0   PCA_0                                                             04/09/2019 09:10:06 PAGE 6   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
